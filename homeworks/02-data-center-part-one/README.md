### Домашно 2
# Data Center, част първа

[Центровете за данни](https://en.wikipedia.org/wiki/Data_center) са големи помещения, които предоставят облачни услуги за корпоративни клиенти.
В нашата задача ще приемем, че един център за данни притежават множество от харддискове, които може да дава под наем на своите клиенти.
Целта ни е да моделираме тези взаимоотношения.
Ще разделим задача на две отделни домашни, като следващото доразвива текущото.
Сега целта ни е да си създадем основата от класове и помощният самоуголемяващ се масив.

## Условие

Забележки:

> Именуването на класове, променливи, член-данни и член-функции не е чак толкова от значение.
> Тук е използван `lowerCamelCase` обаче няма проблем да ползвате `lower_snake_case` ако сте свикнали с него.
> Хубаво е имената да са смислени.

> Всички член-данни е задължително да са `private`.

> Селектори и мутатори (поне селектори) се подразбират. Нужен е начин да се достъпват член-данните.

> Задължително класовете ви да се компилират без грешки.

> По-долу определенията за член-данни са записани във вида `<име на член-данна>: <тип> – обяснение`

Реализирайте следните класове:

### 1. `DynamicArray<T>`
> Тук `T` е шаблонен (произволен) тип

Този клас вече сме разглеждали на [Упражнение 6](/06-dynamic-memory/README.md)

Със следните член-данни:
 - масив от тип `T`, който да държи елементите. Ще го инициалираме в динамичната памет, за можем да я освобождаваме и уголемяваме, когато е нужно.
 - `capacity`: естествено число [< 2³²](https://en.cppreference.com/w/cpp/language/types) – максималният брой елементи, които масивът може да съдържа. Съответства на колко памет е заделена.
 - `size`: естествено число [< 2³²](https://en.cppreference.com/w/cpp/language/types) – броят елементи, които масивът действително съдържа.
 Има приятното свойство, че на позиция `size` е първото свободно място, на което можем да запишем нов елемент.

Винаги е изпълнено, че `size <= capacity`.
Ако `size == capacity` казваме, че масивът е пълен. Ако масивът е пълен и се направи опит да се добави елемент трябва `DynamicArray` да се преоразмерява, тоест да се задели нов масив с по-голяма дължина, да се откопират старите елементи и да се изтрие старият масив.

И следните член-функции:
 - боравим с динамична памет, затова са ни нужни всичките член-функции от каноничното представяне.
 - `void pushBack(const T& element)` – добавя копие на попадения като аргумент елемент към края на масива. Ако масивът е пълен, първо уголемява масива и след това добавя копие накрая.
 - `void popBack()` – премахва елементът накрая на масива.
 - `Т& operator []` – произволен достъп до елемент на масива, абсолютно същото като `operator[]` на обикновените масиви.

### 2. `StorageUnit`
член-данни:
 - `id`: естествено число [< 2³²](https://en.cppreference.com/w/cpp/language/types) – уникално е за всеки отделен обект, тоест няма два различни обекта с еднаво `id`.
 - `pricePerGB`: реално число – цената за всеки гигабайт.
 - `gigabytes`: естествено число [< 2³²](https://en.cppreference.com/w/cpp/language/types) – брой гигабайти, които даден `StorageUnit` поддържа.
 - `owner`: указател към обекти от тип `Company` – самият собственик на StorageUnit-а, а ако няма собственик тази член-данна има стойност `nullptr`.

член-функции:
 - за да може да се правят масиви от този тип е нужно да се дефинира и конструктор по подразбиране.

> Цената на един обект от тип `StorageUnit` е `pricePerGB * gigabytes`.

### 3. `Company`
член-данни:
 - `budget`: реално число – парите, с които компанията разполага.
 - `rentedStorage`: `DynamicArray<StorageUnit*>` – `StorageUnit`-ити, които компанията е наела.

член-функции:
 - за да може да се правят масиви от този тип е нужно да се дефинира и конструктор по подразбиране.

### 4. `DataCenter`
член-данни:
 - `budget`: реално число – парите, с които центърът за данни разполага.
 - `storage`: `DynamicArray<StorageUnit>`
 - `clients`: `DynamicArray<Company>`

член-функции:
 - `void lendStorageTo(const Company& company)` – дава назаем на компанията `company` един свободен (без собственик) `StorageUnit` от `storage`. Ако `company` я няма в масива `clients`, я добавя в него.
 - `void taxClients()` – взима от парите на всяка клиентска компания 10% от цената на всеки `StorageUnit`, който е нейн и ги добавя към бюджета на центъра за данни.
