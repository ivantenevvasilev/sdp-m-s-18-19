# Упражнение 10

На лекции разглеждахме структурата от данни опашка. Знаем че, за тази абстрактна структура от данни достъпът до елементи е FIFO (First in, first out). Това съвпада до представите ни за опашка в истинският живот, и реално опашките имат много ползи в програмирането. За това това упражнение предимно ще упражняваме опашки.
## Задача 1
Да се реализира имплементация на опашка (`Queue`)
За упражнението ще са нужни следните член-функции.
Ще я направим шаблонна, защото както стекът и другите абстрактни структури от данни, не зависи от конкретният тип - нейната задача е да ни предоставя редът на достъп до елементите от произволен тип.

```c++
class Queue {

  ... други неща ...

  void push(const T& x); // добавя елемент в края на опашката
  void pop(T& x); // премахва елемент от началото на опашката
  void head(T& x) const; // намира първият елемент в началото на опашката
  bool empty() const; // казва дали в опашката не се съдържат елементи
  
  ... други неща ...

};
```

## Задача 2
Да се напише функция която принтира опашка, без да променя оригиналната.

```c++
void print_queue(<опашка_от_шаблонен_тип> queue);
```

Тази функция ще ни е полезна за по-нататъчните задачи.

## Задача 3
Да се напише функция, която обръща наобратно реда на елементите на стек, използвайки опашка.

## Задача 4
Да се напише функция, която обръща наобратно реда на елементите на опашка, използвайки стек.

## Задача 5
Да се напише функция която приема опашка `q` и число `n`.
Нека елементът в началото на опашката да е с номер `1` и всеки следващ елемент да има номер с едно по-голям от предишния.
Функцията изменя `q` така че в нея да не се съдържа елементът с номер `n`, но всички останали елементи да са си по местата.

Можем да приемем, че в опашката има поне n елемента.

```c++
T pop_nth(Queue<T>& q, int n)
```

### Примери

| Входни обекти | Обектите след извикване на `pop_nth(q, n)` |
| ----- | ---------------------- |
| q: 1 2 3 4 <br>n: 3 | q: 1 2 4 |
| q: 7 1 2 3 4 <br>n: 1 | q: 1 2 3 4 |
| q: -1 44 10 <br>n: 2 | q: -1 10 |

## Задача 6
Нека напишем клас задача (`Task`), който ще представлява някакво действие което трябва да се изпълни.
За нас една задача ще представлява просто някакъв текст с максимален размер до 100 символа.
Трябва ли динамична памет в този случай? Ами канонично преставяне?

Да се направи функция която приема опашка от задачи, като изпълнява всички задачи в редът в който са добавени (заявени).

## Задача 7 - [Задачата на Йосиф Флавий](https://en.wikipedia.org/wiki/Josephus_problem)
Няколко човека са наредени в кръг. Тях започват да ги избиват по следния начин - като един човек бъде убит, пропускат се последователно `k` на брой хора и се убива следващият. Това продължава докато в кръга остане един човек. В задачата се търси първоначалната позиция на оцелелия. 

Да се напише функция `int getSafePosition(int n, int s, int k)`, която приема като параметри:
 - `n` - брой хора в началото.
 - `s` - началната позиция на първият убит.
 - `k` - броят пропуснати хора между всеки две убийства.
 
Функцията връща първоначалната позиция на последния оцелял.

Тази задача има математическо решение, което е сравнително сложно, обаче ние ще я направим по по-директният (и бавен) начин, симулирайки действията чрез опашка.

