# Упражнение 11

На лекции разглеждахме структурата от данни опашка. Знаем че, за тази абстрактна структура от данни достъпът до елементи е FIFO (First in, first out). Това съвпада до представите ни за опашка в истинският живот, и реално опашките имат много ползи в програмирането. За това това упражнение предимно ще упражняваме опашки.
## Задача 1
Да се реализира имплементация на опашка (`Queue`)
За упражнението ще са нужни следните член-функции.
Ще я направим шаблонна, защото както стекът и другите абстрактни структури от данни, не зависи от конкретният тип - нейната задача е да ни предоставя редът на достъп до елементите от произволен тип.

```c++
class Queue {
  void push(const T& x);
  void pop(T& x);
  void head(T& x) const;
  bool empty() const;
} 
```

## Задача 2
Да се напише функция която принтира опашка

```c++
void print_queue(Queue<T> queue);
```

Тази функция ще ни е полезна за по-нататъчните задачи.

## Задача 3
Да се напише функция която обръща стек, използвайки опашка.

## Задача 4
Да се напише функция която по дадена опашка и число `n`, прави така че елементът който би се върнал след `n` викания на `pop` се премахва, и остатъкът от опашката остава непроменен.

Можем да приемем, че в опашката има поне n елемента.

```c++
T pop_nth(Queue<T>& q, int n)
```

### Примери

| Вход  | Изход на `print_queue` |
| ----- | ---------------------- |
| q: 1 2 3 4 <br>n: 3 | 1 2 4 |
| q: 7 1 2 3 4 <br>n: 1 | 1 2 3 4 |
| q: -1 44 10 <br>n: 2 | -1 10 |

### Задача 5
Нека напишем клас задача (`Task`), който ще представлява някакво действие което трябва да се изпълни.
За нас една задача ще представлява просто някакъв текст с максимален размер до 100 символа.
Трябва ли динамична памет в този случай? Ами канонично преставяне?

Да се направи функция която приема опашка от задачи, като изпълнява всички задачи в редът в който са добавени (заявени).

