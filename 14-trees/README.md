# Дървета
Дърветата имат подобна идея на тази на свързаните списъци, а именно всеки елемент знае за точно тези елементи които са му наследници. Дървото в общата дефиниция не е лимитиран до това да има само два наследника - ляв и десен. Обаче за курсът по Структури от Данни разглеждаме конкретен вид дървета, а именно двоичните дървета.

### Какво е двоично дърво?
Двоичното дърво има стойност на коренът, ляв и десен наследник които са от същият тип.

Например това е структурата на която се базира двоичното дърво:
```c++
template<typename T>
struct TreeNode {
  T item;
  TreeNode<T> * left_tree_node,
                right_tree_node;
};
```

Тя много си прилича с тази на двойно-свързаният списък, толкова си прилича, че само с променяне на името на структурата е точно същата структура като тази на двойно-свързаният списък.
Това което ги различава е семанстиката (смисълът) на структурата.

### С какво са ни полезни дърветата?
Те имат много употреби, една от които е моделиране на изрази с бинарни и унарни изрази (Expression Trees). И много други видове дървета, които са полезни (и дават възможност на езиците за програмиране да съществуват като цяло). Но доста от тях сами по себе си са дълбоки теми.

Ще разглеждаме предимно Expression Trees и Двоични Наредени Дървета (Binary Search Tree), и някои подобрения над Двоичните Наредени Дървета.

Но като за начало, ще работим с просто двоично дърво и основните действия с него.

Това упражнение ще построим заедно някаква имплементация на двоично дърво.

### Задача 1
Първоначално, знаейки че дърветата ще са от произволна размерност се досещаме че ще ни трябва канонично представяне.
Единствената същинска член-данна която има едно дърво е коренът му, той знае как да стигне до своите деца и те съответно до техните, така че във функциите ще трябва да се грижим точно за коренът.

Да се имплементират:
- конструктор по подразбиране
- контруктурът за копиране
- операторът за копиране
- деструкторът

### Задача 2
Сега ще реализираме основните операции с абстрактното двоично дърво.

```c++
bool empty() const;
TreeNode<T> * get_tree_root() const;
T root_value() const;

void create_tree(const T& root_element, const Tree<T>& left_tree, const Tree<T>& right_tree);
```

Функциите не са много - защото все още се занимаваме с абстрактното двоично дърво - тоест ние не сме уточнили как се добавят елементи. 
