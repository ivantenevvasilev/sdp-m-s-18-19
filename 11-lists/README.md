# Упражнение 11

Тази седмица на лекции видяхме различните видове свързани списъци. Ние ще ги разглеждаме в опростен вид. Ще работим само върху структурата която списъкът използва.
Идеята на свързаният списък е че всеки елемент знае нещо за неговите "съседи". В едносвързъният списък всеки елемент знае за този който е след него, в двусвързаният - този преди и този след него.

Елементите се помещават в "кутии", всяка от които държи самата стойност и връзка (указател) към следващата (ако е двусвързан също и предишната) кутия. Списъкът представлява просто последователност от кутии.

### Например
Ето я кутията за едносвързан списък
```c++
template<typename T>
struct Node {
  Node<T> * next;
  T item;
};
```

Ако имаме следният списък, и начален елемент указател към първият елемент в променлива `start`

![List-1](images/list-1.png)

От тук можем да достъпим елементите по следният начин

```c++
  // Some code here...
  
  int first_element = start->item;
  int second_element = start->next->item;
  int third_element = start->next->next->item;
  Node<T> * end = start->next->next->next; // end == NULL

  // More code...
```

Тук виждаме, че може да достъпим всеки елемент като така верижно взимаме следващия ползвайки `next` полето. Всичко добре, обаче ако не знаем броят на елементите как бихме го взели?
От този пример се забелязва също така, че като следващият елемент сочи към стойността `NULL` - това значи, че списъкът е свършил. Ползвайки това, бихме могли да напишем следното

```c++
  // Get start...
  current = start;
  while (current != NULL) {
    cout << current->item << ' ';
    current = current->next; // Знаем че current не е NULL, в противен случай цикълът би приключил
  }
```

> В следващите няколко задачи примаме че списъкът представлява указател към първата си кутия.

### Задача 1
Използвайки структурата `Node`, показана по-горе, от целочислен тип, да се напише функция която сумира елементите на нашият "списък", представен във вида като указател към първата кутия.

### Задача 2
Да се напише функция която замества елемнтът на `n`-та позиция в списък.

```c++
void replace(Node<T>*& start, int n, T item);
```

#### Пример

![List-5](images/list-5.png)

![List-5-Change](images/list-5-modified.png)



### Задача 3
Да се напише функция която изтрива първият елемент от "списъкът" започващ от `Node` който съвпада с `item` и връща истина в случая който премахва елемент, и ако не променя списъкът - лъжа

```c++
bool remove_first_occurance(Node<T> *& start, T item);
```

### Пример
Извикваме със следният списък и `item = 5`

![List-2](images/list-2.png)

![List-2-Change](images/list-2-modification.png)

![List-2-Final](images/list-2-final.png)

#### Важно! 

Какво би станало ако извикаме функцията с елемент съвпадащ с първият, началото.

### Задача 4
Да се напише функция която добавя елемент след `n`-тият елемент в списъка.
Ако списъкът свърши преди позиция `n` да се изпише подходящо съобщение и прекрати изпълнението на функцията.

```c++
void add_after(Node<T> *& start, int n, T value);
```

#### Пример
Входни данни списъкът и `n = 2`

![List-3](images/list-3.png)

Създава нова кутия и пренасочва указателите по следният начин

![List-Add](images/list-3-add.png)

Окончателно списъкът изглежда така

![List-Final](images/list-3-fin.png)

Входни данни списъкът и `n = 3`

![List-4](images/list-4.png)

Създава нова кутия и пренсочва указателят към следващият елемент на последният елемент към новият. И новият има за следващ елемент `NULL` (тоест следващият елемент на елемента след който бива добавен)

![List-Add](images/list-4-change.png)

Окончателно списъкът изглежда така

![List-Final](images/list-4-fin.png)

### Задача 5
Да се напише функция, която принтира в обратен ред елементите на списък.
```c++
void print_reverse(Node<T>* start)
```

### Задача 6
Да се напише функция, която обръща реда на елементите на списък.
```c++
void reverse(Node<T>*& start)
```

### Задача 7
Да се напише функция, която сортира елементите на списък.
```c++
void sort(Node<T>*& start)
```

## Работа със класът свързан списък.

Тази последователност от `Node`-ове можем много лесно да я "облечем" в един клас - самият свързан списък. [Ето примерна имплементация.](list-implementation/List.h)

### Задача 8
Да се напише член-функция която трие елемента на начална позиция на свързан с една връзка.

```c++
void deleteFront();
```

### Задача 9
Да се напише член-функция която достъпва елементът на първата позиция в свързан списък с една връзка.
```c++
T getFront() const;
```

### Задача 10
Да се напише имплементация на опашка използвайки нашата подобрена версия на свързаният списък с една връзка.

