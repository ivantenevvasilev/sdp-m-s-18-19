# Упражнение 3

## Предтекст
Нека предположим, че разработваме програма за някакъв хотел, бихме искали да опишем какво представлява една стая. Важното за един хотел е цената на стаята, тъй като стаите ще бъдат предлагани на клиенти. Интересуваме се от размерите, защото клиентите трябва да имат представа за какво ще плащат. Хотелът също така трябва да има начин да различава стаите, за това въвеждаме номер на стая (не искаме хотелът да даде една и съща стая на двама различни клиента).


## Задача 1

Да се напише структура (или клас) описващ Стая (**Room**). 

Стаята за целите на нашата задача ще се описва чрез следните полета:

1. Номер представляващ неотрицателно число
2. Размери (ширина, дълбочина и височина)
3. Наем за един ден

За типът **Room** да се напишат следните член функции

1. Функции за достъп до член-данните
2. Функция пресмятаща обема на стаята

## Задача 2
Да се напише функция която въвежда стаи и функция която да принтира стаи.

```c++
void print_room(Room& room);
void enter_room(Room& room);
```

Целта на тези функции е по-лесно визуализиране и въвеждане на данните с които работим за следващите задачи.

### Въвеждане
Ще въвеждаме стаи в форматът `<номер> <ширина> <дълбочина> <височина> <цена>`
Може въвеждането и принтирането да са в друг формат, но в този случай ще трябва да промените примерният вход и изход, така че да може да пробвате вашите решения.

|       Вход        |                                          Описание                                                 |
| ----------------  | ------------------------------------------------------------------------------------------------  |
| 0 50 50 20 21.50  | Стая №0 със **ширина** 50, дълбочина 50, **височина** 20, и **наем** за ден на стойност от 21.50  |
| 23 43 62 12 55.73 | Стая №23 със **ширина** 43, дълбочина 62, **височина** 12, и **наем** за ден на стойност от 55.73 |
| 4 20 25 10 10     | Стая №4 със **ширина** 20, дълбочина 25, **височина** 10, и **наем** за ден на стойност от 10     |


### Принтиране
Ще принтираме стая в следният формат:
`Room #<номер> has dimensions (<ширина>, <дълбочина>, <височина>) and volume <обем> is available for $<цена> per day`

Стаята в примерите ще е в същият формат като входът при въвеждането, показан по-горе.

|      Стая         |                                        Изход                                                       |
| ----------------- | -------------------------------------------------------------------------------------------------- |
| 0 20 20 20 15.10  | Room #0 has dimensions (20, 20, 20) and volume 8000 is available for $15.1 per day                 |
| 0 50 50 20 21.50  | Room #0 has dimensions (50, 50, 20) and volume 50000 is available for $21.5 per day                |
| 23 43 62 12 55.73 | Room #23 has dimensions (43, 62, 12) and volume 31992 is available for $55.73 per day              |
| 4 20 25 10 10     | Room #4 has dimensions (20, 25, 10) and volume 5000 is available for $10 per day                   |


## Задача 3
Да се напише сортираща фунцкия която подрежда стаите в ред по нарастване на размера и друга която сортира по цена.

```c++
void sort_rooms_by_size(Room * rooms, int count);
void sort_rooms_by_price(Room * rooms, int count);
```

За лесно тестване може да копирате следните функции
```c++
void print_room_array(Room * rooms, int count) {
	for (int i = 0; i < count; ++i) {
		print_room(rooms[i]);
	}
}

void enter_room_array(Room * rooms, int count) {
	for (int i = 0; i < count; ++i) {
        enter_room(rooms[i]);
	}
}

int main() {
	int count;
	Room rooms[100];
	cin >> count;
	enter_room_array(rooms, count);
	sort_rooms_by_price(rooms, count);
	// or sort_rooms_by_size(rooms, count); for other example
	print_room_array(rooms, count);
	return 0;
}

```

Примерен изход за функцията `sort_rooms_by_size`
|       Вход      | Изход (сортиран по размер възходящо) |
| --------------- | ---------------------------------- |
|4 <br> 0 20 20 20 15.10 <br> 0 50 50 20 21.50 <br> 23 43 62 12 55.73 <br> 4 20 25 10 10|Room #4 has dimensions (20, 25, 10) and volume 5000 is available for $10 per day<br>Room #0 has dimensions (20, 20, 20) and volume 8000 is available for $15.1 per day<br>Room #23 has dimensions (43, 62, 12) and volume 31992 is available for $55.73 per day<br>Room #0 has dimensions (50, 50, 20) and volume 50000 is available for $21.5 per day|

Примерен изход за функцията `sort_rooms_by_price`
|       Вход      | Изход (сортиран по цена възходящо) |
| --------------- | ---------------------------------- |
|4 <br> 0 20 20 20 15.10 <br> 0 50 50 20 21.50 <br> 23 43 62 12 55.73 <br> 4 20 25 10 10 | Room #4 has dimensions (20, 25, 10) and volume 5000 is available for $10 per day <br>Room #0 has dimensions (20, 20, 20) and volume 8000 is available for $15.1 per day <br>Room #0 has dimensions (50, 50, 20) and volume 50000 is available for $21.5 per day<br>Room #23 has dimensions (43, 62, 12) and volume 31992 is available for $55.73 per day|


**Бонус**:
Двете функции като код биха си приличали много, единственото място в което ще се различават е при сравняването на две стаи. Програмистите са мързеливи и най-вероятно биха направили едно от следните две неща:
1. Копират функцията и променят сравнението
2. Измислят нещо по-общо за да спестят писане

Първото нещо има един фундаментален проблем, и това е че ако в една от двете функции има бъг, то при копирането този бъг ще е на две места. Ако го забележим по-късно и го оправим има шанс да забравим да го оправим на другите места където кодът е копиран. В случаят на 2 копия не е твърде трудно човек да се досети, обаче при повече копия и повече хора работещи върху един и същ код, шансовете се увеличават драстично. За това, какво бихме могли да направим да предотвратим това?

В езикът C++ има нещо наречено [функции от по-висок ред](https://www.learncpp.com/cpp-tutorial/78-function-pointers/).
Функция от по-висок е функция която прави едно от две неща:
* Приема друга функция като аргумент
* Връща функция като резултат от изпълнението си

В нашият случай първото звучи като нещо което би ни свършило работа, бихме искали да имаме сортираща функция която можем да и кажем как да сравнява две стаи.
```c++
// Сортира стаи, като ги размества ако лявата стая е "по-голяма" от дясната
// Под "по-голяма" се има предвид оценява с по-голяма стойност от дясната
void sort_rooms(Room * rooms, int count, bool(*comparator) (Room& left, Room& right));

// Предполагайки че член-функцията price връща цената на стая
bool is_room_more_expensive(Room& left, Room& right) {
    return left.price() > right.price();
}

// Предполагайки че член-функцията volume връща обема на стаята
bool is_room_bigger(Room& left, Room& right) {
    return left.volume() > right.volume();
}
```

Какво печелим ако го напишем по този начин?
1. Можем да напишем различни функции които сравняват по други критерии.
2. Сортирането може да ги подрежда в обратен ред ако обърнем булевото условие
3. Ако сменим сортиращият алгоритъм, имаме едно единствено място в което трябва да го направим и кодът ще продължи да работи.

## Задача 4
Да се напише функция която по даден масив от стаи, сумира техните цени.
```c++
double sum_prices_for_rooms(Room * rooms, int count);
```
Примерен изход за функцията `sum_prices_for_rooms`
|       Вход                                                                             | Резултат |
| -------------------------------------------------------------------------------------- | -------- |
|4 <br> 0 20 20 20 15.10 <br> 0 50 50 20 21.50 <br> 23 43 62 12 55.73 <br> 4 20 25 10 10 |  102.33  |

## Задача 5
Нека имаме масив с максимален размер от 100 от стаи. Искаме да напишем функция reserve_room, със следната сигнатура 
```c++ 
bool reserve_room(Room * rooms, int room_count, int room_number);
``` 

Където при срещане на стая със същият номер, я премахва от масивът и измества всички следващи стаи наляво, така че масивът да бъде в изрядно състояние (тоест да няма празни стаи)
В случай че стая с търсен номер не съществува, функцията връща false. Това ни е нужно защото при премахване на елемент от масивът той си променя дължината, но ако няма елемент който да премахнем, дължината си остава същата. Това ще бъде нашият начин чрез който разбираме дали дължината се е намалила или не.
**Пример**:
|       Вход                                                                                                   | Състояние на масивът след изпълнение                 | Върнат резултат | Пояснение                                                                                                                                              |
| ------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------- | --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |
| room_number: 0 <br> room_count: 1 <br> rooms: [(0 20 20 20 15.10)]                                           | rooms: []                                            |      true       | Стая номер 0 е намерена в масивът, и бива премахната от масивът, оставяйки го празен. Връща true, защото елемент е премахнат от масива.                |
| room_number: 3 <br> room_count: 1 <br> rooms: [(0 20 20 20 15.10)]                                           | rooms: [(0 20 20 20 15.10)]                          |      false      | Стая със номер 3 не е намерена в масивът, масивът rooms остава непроменен и върнатият резултат е false                                                 |
| room_number: 4 <br> room_count: 1 <br> rooms: [(0 20 20 20 15.10), **(4 20 25 10 10)**, (23 43 62 12 55.73)] | rooms: [(0 20 20 20 15.10), (23 43 62 12 55.73)]     |      true       | Стая номер 4 е намерена и премахната, всички елементи след нея се изместват с една позиция на ляво, и резултатът е true защото елемент е бил премахнат |