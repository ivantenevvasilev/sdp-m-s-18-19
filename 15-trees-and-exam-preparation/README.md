# Упражнение 15

Отново ще говорим за дървета в първата половина на упражнението, като след това ще разгледаме типове задачи които предложихте.

### Задача 1
Предният час имплементирахме почти всичко нужно за цялостната имплементация на двоично наредено дърво, липсва ни само копирането. Нашата задача ще бъде да напишем функция която при подаден указател към коренът на дърво, да прави копие на цялото дърво и връща указател към коренът на новото дърво.

### Задача 2
Използвайки [примерните решения от предната седмица](../14-trees/sample-solutions/trees.cpp), ще сглобим цял клас двоично наредено нарво (`BinarySearchTree`) който има следната функционалност

```c++
template <class T>
class BinarySearchTree {
public:
  BinarySearchTree();
  BinarySearchTree(const BinarySearchTree<T>& left, const BinarySearchTree<T>& right, root);

  BinarySearchTree(const BinarySearchTree<T>& other);
  BinarySearchTree& operator=(const BinarySearchTree<T>& other);

  void add(T item);
  void remove(T item);
  bool contains(T item);

  TreeNode<T> * get_root();
  
  TreeNode<T> * find(T item); 

  ~BinarySearchTree();
private:
  TreeNode<T> * root;
};
```

Като естествено трябва да направим канонично представяне на класът защото `TreeNode<T>*` бива заделено динамично. Обаче голяма част от функционалността е готова (копи функцията от предната задача, и триенето от предната седмица.)

### Задача 3
Направете функция която от подадено двоично наредено дърво, обхожда дървото в ред: Корен ляво дясно и го записва във едносвързан списък.

```c++
template <class T>
List<T> root_left_right(BinarySearchTree<T>& tree); 
```

### Задача 4
Като загрявка, да се напише функция която приема като вход израз от видът:
```
<израз> ::= <буква> | f(<израз>) | g(<израз>)
```

Където
- `f(x)` дава буквата след `x` и ако `x` е последната буква в азбуката, връща `'a'`
- `g(x)` дава буквата преди `x` и ако `x` е първата буква в азбуката, връща `'z'`

И връща резултатът от редуцирането на изразът до израз съставен от единствена буква

### Задача 5
Да се напише функция която приема вход израз от видът

```
<израз> ::= <буква> | f(<израз>, <израз>) | g(<израз>, <израз>)
```

Където
- `f(x, y)` дава лексикографки по-голямата буква измежду `x` и `y`
- `g(x, y)` дава лексикографки по-малката буква измежду `x` и `y`

### Задача 6
Да се напише функция която приема вход израз от видът
```
<израз> ::= <цифра> | f(<израз>, <израз>) | g(<израз>)
```

Където
- `f(x, y)` връща `(x + y) % 10`
- `g(x)` връща `(x + 1) % 10`

### Задача 7
Да се напише функция която приема вход израз от видът
```
<израз> ::= <цифра> | f(<израз>, <израз>, <израз>) | g(<израз>, <израз>) | h(<израз>, <израз>, <израз>, <израз>))
```

Където
- `f(x, y, z)` връща `(53x^2 + 3y + 8z) % 10`
- `g(x, y)` връща `(24x^3 + y^2) % 10`
- `h(x, y, z, t)` връща `(x + y + z + t) % 10`

### Задача 8
Да се напише клас `Bank` където банката си има 
- име (name) - с произволен размер
- множество от потребители (броят на потребители не се знае по време на компилация) - те представляват просто имена с максимална дължина от 100 знака (може да се приеме че броят на потребители ще се подава в конструктор)

Да се напише член функция на `Bank` която принтира имената на всички потребители и техният брой.
Също така да се напише член функция която връща името на името на банката, друга член функция която намира броят на потребители.

